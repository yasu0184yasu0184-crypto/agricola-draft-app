<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Agricola Draft Practice</title>
    <style>
        body { font-family: sans-serif; }
        .hand { border: 1px solid #ccc; padding: 10px; margin: 10px; display: flex; flex-wrap: wrap; }
        .card { cursor: pointer; background: #f0f0f0; margin: 5px; padding: 5px; width: 150px; position: relative; text-align: center; }
        .selected { background: #ffff00; }
        button { margin: 10px; }
        .picked-list { display: flex; flex-wrap: wrap; }
        #okButton { font-size: 24px; padding: 10px 20px; }
        .card img { max-width: 100%; height: auto; } /* 画像サイズ調整 */
        .combo-mark { color: red; background: yellow; font-size: 14px; font-weight: bold; position: absolute; top: 5px; right: 5px; padding: 2px 4px; border-radius: 4px; } /* 黄色背景赤文字で"コンボ" */
        #comboInfo { border: 1px solid #ddd; padding: 10px; margin: 10px; background: #f9f9f9; font-size: 14px; } /* コンボ理由表示枠 */
        .round-section { margin: 10px; padding: 10px; border: 1px solid #ddd; display: flex; align-items: center; flex-wrap: wrap; }
        .round-select { margin: 5px; font-size: 2em; } /* プルダウンサイズ2倍 */
        .round-label { font-size: 1em; } /* 表示サイズ半分 */
        .round-input { font-size: 2em; width: 200px; } /* 入力枠サイズ2倍調整 */
        .action-group { display: flex; flex-wrap: nowrap; align-items: center; } /* 飯以降同じ行 */
        .round-header { margin-right: 10px; font-size: 1.5em; font-weight: bold; } /* R表記調整, スペース追加 */
    </style>
</head>
<body>
    <h1>アグリコラ ドラフト練習</h1>
    <div id="ratingSelection">
        <label>Ratingタイプ選択:</label>
        <select id="ratingType">
            <option value="rating_a">理論</option>
            <option value="rating_b">ボドゲニスト</option>
        </select>
        <button onclick="loadCards()">ドラフト開始</button>
    </div>
    <div id="playerHand"></div>
    <div id="comboInfo"></div> <!-- コンボ理由表示 -->
    <div id="status"></div>
    <div id="pickedCards"></div>
    <div id="roundActions" style="display: none;"></div> <!-- ドラフト後ラウンド選択UI -->

    <script>
        let occupations = [];
        let minors = [];
        let players = Array(5).fill().map(() => ({ occHand: [], minHand: [], pickedOcc: [], pickedMin: [] }));
        let currentPlayer = 0;
        let playerTurn = 1; // 番手保持
        let round = 0;
        let selectedOccIndex = -1;
        let selectedMinIndex = -1;
        let selectedRating = 'rating_a'; // デフォルト

        const commands = ["木4", "木3", "SP", "大進歩", "レン3", "レン2", "レン6", "葦2", "葦1", "石1葦1木1", "飯-0職業", "飯-1職業", "小劇場", "漁", "畑", "麦", "種まき", "日雇い"];

        function shuffle(array) {
            let shuffled = array.slice();
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        async function loadCards() {
            selectedRating = document.getElementById('ratingType').value; // 選択されたratingタイプ
            try {
                const occResponse = await fetch('occupation.json');
                if (!occResponse.ok) {
                    throw new Error(`occupation.jsonの読み込みエラー: ${occResponse.status}`);
                }
                occupations = await occResponse.json();

                const minResponse = await fetch('minor.json');
                if (!minResponse.ok) {
                    throw new Error(`minor.jsonの読み込みエラー: ${minResponse.status}`);
                }
                minors = await minResponse.json();

                // combosが文字列なら配列に変換
                occupations.forEach(c => {
                    if (typeof c.combos === 'string') {
                        try {
                            c.combos = JSON.parse(c.combos);
                        } catch (e) {
                            console.error('Combos parse error for occupation:', c.name_jp, e);
                            c.combos = [];
                        }
                    }
                });
                minors.forEach(c => {
                    if (typeof c.combos === 'string') {
                        try {
                            c.combos = JSON.parse(c.combos);
                        } catch (e) {
                            console.error('Combos parse error for minor:', c.name_jp, e);
                            c.combos = [];
                        }
                    }
                });

                startDraft();
            } catch (error) {
                alert('JSONファイルの読み込みに失敗しました。ファイル名やパスを確認してね。エラー: ' + error.message);
            }
        }

        function startDraft() {
            // 番手をランダム決定 (1-5)
            playerTurn = Math.floor(Math.random() * 5) + 1;
            // updateTurnInfo(); // 番手表示なし

            // デッキシャッフル＆配布（5人7枚ずつ、E/I/K全カードからランダム35枚ずつ抽出）
            let occDeck = shuffle(occupations).slice(0, 35);
            let minDeck = shuffle(minors).slice(0, 35);
            for (let i = 0; i < 5; i++) {
                players[i].occHand = occDeck.splice(0, 7);
                players[i].minHand = minDeck.splice(0, 7);
                players[i].pickedOcc = [];
                players[i].pickedMin = [];
            }
            round = 0;
            selectedOccIndex = -1;
            selectedMinIndex = -1;
            document.getElementById('roundActions').style.display = 'none'; // 非表示リセット
            // document.getElementById('ratingSelection').style.display = 'none'; // ボタン消さない
            showHand();
        }

        // function updateTurnInfo() {
        //     document.getElementById('turnInfo').innerHTML = `<p style="font-weight: bold; color: blue;">あなたの番手: ${playerTurn}番手</p>`;
        // }

        function showHand() {
            // updateTurnInfo(); // 番手表示なし

            // 手札をrating降順ソート（表示時のみ、ピックには影響なし）
            const sortedOccHand = [...players[0].occHand].sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0)); // 選択されたrating使用
            const sortedMinHand = [...players[0].minHand].sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));

            const handDiv = document.getElementById('playerHand');
            handDiv.innerHTML = '<h2>' + playerTurn + '番手の手札</h2>'; // 番手に置き換え
            handDiv.innerHTML += '<div class="hand"><h3>職業</h3>' + sortedOccHand.map((c) => {
                const originalIndex = players[0].occHand.findIndex(card => card.name_jp === c.name_jp); // name_jpでマッチ（ユニーク前提）
                const isSelected = originalIndex === selectedOccIndex;
                const combos = checkCombos(c, players[0].pickedOcc.concat(players[0].pickedMin).concat(players[0].occHand).concat(players[0].minHand)); // 候補同士+手札を含む
                const hasCombo = combos.length > 0;
                const comboMark = hasCombo ? `<span class="combo-mark">コンボ</span>` : '';
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card ${isSelected ? 'selected' : ''}" onclick="pickCard('occ', ${originalIndex}); showComboReason('${c.name_jp}', '${combos.join('\\n')}')">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}${comboMark}</div>`;
            }).join('') + '</div>';
            handDiv.innerHTML += '<div class="hand"><h3>進歩</h3>' + sortedMinHand.map((c) => {
                const originalIndex = players[0].minHand.findIndex(card => card.name_jp === c.name_jp);
                const isSelected = originalIndex === selectedMinIndex;
                const combos = checkCombos(c, players[0].pickedOcc.concat(players[0].pickedMin).concat(players[0].occHand).concat(players[0].minHand)); // 候補同士+手札を含む
                const hasCombo = combos.length > 0;
                const comboMark = hasCombo ? `<span class="combo-mark">コンボ</span>` : '';
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card ${isSelected ? 'selected' : ''}" onclick="pickCard('min', ${originalIndex}); showComboReason('${c.name_jp}', '${combos.join('\\n')}')">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}${comboMark}</div>`;
            }).join('') + '</div>';
            
            const pickedDiv = document.getElementById('pickedCards');
            pickedDiv.innerHTML = '<h2>' + playerTurn + '番手の選んだカード</h2>'; // 番手に置き換え
            pickedDiv.innerHTML += '<div class="picked-list"><h3>職業</h3>' + players[0].pickedOcc.map(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            }).join('') + '</div>';
            pickedDiv.innerHTML += '<div class="picked-list"><h3>進歩</h3>' + players[0].pickedMin.map(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            }).join('') + '</div>';

            document.getElementById('status').innerHTML = `<button id="okButton" onclick="passHand()" ${selectedOccIndex === -1 || selectedMinIndex === -1 ? 'disabled' : ''}>OK</button>`;
        }

        function pickCard(type, index) {
            if (type === 'occ') {
                selectedOccIndex = index;
            } else {
                selectedMinIndex = index;
            }
            showHand();
        }

        function passHand() {
            if (selectedOccIndex === -1 || selectedMinIndex === -1) return;

            // プレイヤー1のピック
            const pickedOcc = players[0].occHand.splice(selectedOccIndex, 1)[0];
            const pickedMin = players[0].minHand.splice(selectedMinIndex, 1)[0];
            players[0].pickedOcc.push(pickedOcc);
            players[0].pickedMin.push(pickedMin);

            // 他のプレイヤー（AI）は最高rating ±5範囲内でランダムピック
            for (let i = 1; i < 5; i++) {
                // 職業: rating降順ソートして最高rating取得
                players[i].occHand.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
                const maxRating = players[i].occHand[0]?.[selectedRating] || 0;
                const candidatesOcc = players[i].occHand.filter(c => (c[selectedRating] || 0) >= maxRating - 5 && (c[selectedRating] || 0) <= maxRating + 5);
                if (candidatesOcc.length > 0) {
                    const randomIndex = Math.floor(Math.random() * candidatesOcc.length);
                    const bestOcc = candidatesOcc[randomIndex];
                    const handIndex = players[i].occHand.findIndex(c => c.name_jp === bestOcc.name_jp); // 名前でインデックス検索
                    players[i].occHand.splice(handIndex, 1);
                    players[i].pickedOcc.push(bestOcc);
                } else {
                    // 候補なしならランダム
                    const randOcc = Math.floor(Math.random() * players[i].occHand.length);
                    players[i].pickedOcc.push(players[i].occHand.splice(randOcc, 1)[0]);
                }

                // 進歩: 同上
                players[i].minHand.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
                const maxRatingMin = players[i].minHand[0]?.[selectedRating] || 0;
                const candidatesMin = players[i].minHand.filter(c => (c[selectedRating] || 0) >= maxRatingMin - 5 && (c[selectedRating] || 0) <= maxRatingMin + 5);
                if (candidatesMin.length > 0) {
                    const randomIndex = Math.floor(Math.random() * candidatesMin.length);
                    const bestMin = candidatesMin[randomIndex];
                    const handIndex = players[i].minHand.findIndex(c => c.name_jp === bestMin.name_jp);
                    players[i].minHand.splice(handIndex, 1);
                    players[i].pickedMin.push(bestMin);
                } else {
                    const randMin = Math.floor(Math.random() * players[i].minHand.length);
                    players[i].pickedMin.push(players[i].minHand.splice(randMin, 1)[0]);
                }
            }

            // 手札回転: 職業時計回り、進歩反時計回り
            const nextOcc = players.map(p => p.occHand);
            const nextMin = players.map(p => p.minHand);
            for (let i = 0; i < 5; i++) {
                players[i].occHand = nextOcc[(i + 1) % 5];
                players[i].minHand = nextMin[(i + 4) % 5];
            }

            round++;
            selectedOccIndex = -1;
            selectedMinIndex = -1;

            if (round < 7) {
                showHand();
            } else {
                document.getElementById('status').innerHTML = 'ドラフト終了！';
                showHand(); // 最終手札はピック済みなので表示更新
                showRoundActions(); // ドラフト後ラウンド選択UI表示
            }
        }

        function showRoundActions() {
            const roundActionsDiv = document.getElementById('roundActions');
            roundActionsDiv.style.display = 'block';
            roundActionsDiv.innerHTML = '<h2>ラウンドアクション選択</h2>';
            for (let r = 1; r <= 4; r++) {
                roundActionsDiv.innerHTML += `<div class="round-section"><h3 class="round-header">R${r}</h3>` +
                    createInput('1手目:') +
                    createInput('2手目:') +
                    '<br>' + // 飯以降開行
                    '<div class="action-group">' +
                    createSelect('飯', [0,1,2,3,4,5,6,7,8]) +
                    createSelect('木', [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) +
                    createSelect('レ', [0,1,2,3,4,5,6]) +
                    createSelect('葦', [0,1,2,3,4,5]) +
                    createSelect('石', [0,1,2,3]) +
                    createSelect('麦', [0,1,2,3,4]) +
                    createSelect('野', [0,1,2,3,4]) +
                    '</div>' +
                    '</div>';
            }
        }

        function createInput(label) {
            return `<label class="round-label">${label} <input type="text" class="round-input" pattern="^[ぁ-ゖ]+$" title="全角ひらがなのみ入力してください"></label>`;
        }

        function createSelect(label, options) {
            let select = '<select class="round-select">';
            options.forEach(opt => {
                select += `<option value="${opt}">${opt}</option>`;
            });
            select += '</select>';
            return `<label class="round-label">${label} ${select}</label>`;
        }

        // コンボチェック関数（JSONに"combos"キーがある前提: c.combos = [{target_id: "ID", reason: "説明"} ]）
        function checkCombos(card, allCards) {
            if (!card.combos) return [];
            return card.combos.filter(combo => allCards.some(p => p.id === combo.target_id)).map(combo => combo.reason);
        }

        // コンボ理由表示関数
        function showComboReason(cardName, reasons) {
            document.getElementById('comboInfo').innerHTML = `<h3>${cardName}のコンボ理由</h3><p>${reasons.replace(/\\n/g, '<br>')}</p>`;
        }
    </script>
</body>
</html>
