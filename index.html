<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Agricola Draft Practice</title>
    <style>
        body { font-family: sans-serif; }
        .hand { border: 1px solid #ccc; padding: 10px; margin: 10px; display: flex; flex-wrap: wrap; }
        .card { cursor: pointer; background: #f0f0f0; margin: 5px; padding: 5px; width: 150px; position: relative; text-align: center; }
        .selected { background: #ffff00; }
        button { margin: 10px; }
        .picked-list { display: flex; flex-wrap: wrap; }
        #okButton { font-size: 24px; padding: 10px 20px; }
        .card img { max-width: 100%; height: auto; } /* 画像サイズ調整 */
        .combo-mark { color: red; background: yellow; font-size: 14px; font-weight: bold; position: absolute; top: 5px; right: 5px; padding: 2px 4px; border-radius: 4px; } /* 黄色背景赤文字で"コンボ" */
        #comboInfo { border: 1px solid #ddd; padding: 10px; margin: 10px; background: #f9f9f9; font-size: 14px; } /* コンボ理由表示枠 */
        .round-section { margin: 10px; padding: 10px; border: 1px solid #ddd; display: flex; align-items: center; flex-wrap: wrap; }
        .round-select { margin: 5px; font-size: 2em; } /* プルダウンサイズ2倍 */
        .round-label { font-size: 1em; } /* 表示サイズ半分 */
        .round-input { font-size: 2em; width: 200px; } /* 入力枠サイズ2倍調整 */
        .action-group { display: flex; flex-wrap: nowrap; align-items: center; } /* 飯以降同じ行 */
        .round-header { margin-right: 10px; font-size: 1.5em; font-weight: bold; } /* R表記調整, スペース追加 */
        .candidate-zone { border: 1px solid #999; padding: 10px; margin: 10px; background: #f0f0f0; font-size: 16px; }
        .candidate-container { display: flex; justify-content: space-between; } /* 横並びコンテナ */
        .candidate-column { width: 45%; } /* 列幅調整 */
        .candidate-hand { display: flex; flex-direction: row; flex-wrap: nowrap; overflow-x: auto; min-width: 100%; white-space: nowrap; } /* 横並び強制、横長枠 */
        .candidate-card { width: 75px; margin: 5px; display: inline-block; } /* 候補カードサイズ1/2に調整, inline-blockで横強制 */
        .candidate-card img { max-width: 100%; height: auto; }
        .candidate-title { font-size: 18px; font-weight: bold; color: #333; margin-bottom: 5px; }
    </style>
</head>
<body>
    <h1>アグリコラ ドラフト練習</h1>
    <div id="ratingSelection">
        <label>Ratingタイプ選択:</label>
        <select id="ratingType">
            <option value="rating_a">理論</option>
            <option value="rating_b">ボドゲニスト</option>
        </select>
        <button onclick="loadCards()">ドラフト開始</button>
    </div>
    <div id="playerHand"></div>
    <div id="comboInfo"></div> <!-- コンボ理由表示 -->
    <div id="status"></div>
    <div id="pickedCards"></div>
    <div id="candidateZone" style="display: none;"></div> <!-- 候補表示ゾーン -->
    <div id="roundActions" style="display: none;"></div> <!-- ドラフト後ラウンド選択UI -->
    <script>
        let occupations = [];
        let minors = [];
        let players = Array(5).fill().map(() => ({ occHand: [], minHand: [], pickedOcc: [], pickedMin: [] }));
        let currentPlayer = 0;
        let playerTurn = 1; // 番手保持
        let round = 0;
        let selectedOccIndex = -1;
        let selectedMinIndex = -1;
        let selectedRating = 'rating_a'; // デフォルト
        let sixthCandidatesOcc = []; // 6枚目候補 (職業，下位3枚)
        let sixthCandidatesMin = []; // 6枚目候補 (進歩，下位3枚)
        let seventhCandidatesOcc = []; // 7枚目候補 (職業，下位2枚)
        let seventhCandidatesMin = []; // 7枚目候補 (進歩，下位2枚)
        const commands = ["木4", "木3", "SP", "大進歩", "レン3", "レン2", "レン6", "葦2", "葦1", "石1葦1木1", "飯-0職業", "飯-1職業", "小劇場", "漁", "畑", "麦", "種まき", "日雇い"];
        function shuffle(array) {
            let shuffled = array.slice();
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
async function loadCards() {
    selectedRating = document.getElementById('ratingType').value; // 選択されたratingタイプ
    try {
        const occResponse = await fetch('occupation.json');
        if (!occResponse.ok) {
            throw new Error(`occupation.jsonの読み込みエラー: ${occResponse.status}`);
        }
        occupations = await occResponse.json();
        occupations.forEach(c => {
            if (!Array.isArray(c.combos)) {
                c.combos = [];
            }
        });
        const minResponse = await fetch('minor.json');
        if (!minResponse.ok) {
            throw new Error(`minor.jsonの読み込みエラー: ${minResponse.status}`);
        }
        minors = await minResponse.json();
        minors.forEach(c => {
            if (!Array.isArray(c.combos)) {
                c.combos = [];
            }
        });
        startDraft();
    } catch (error) {
        alert('JSONファイルの読み込みに失敗しました。ファイル名やパスを確認してね。エラー: ' + error.message);
    }
}
        function startDraft() {
            // 番手をランダム決定 (1-5)
            playerTurn = Math.floor(Math.random() * 5) + 1;
            // updateTurnInfo(); // 番手表示なし
            // デッキシャッフル＆配布（5人7枚ずつ、E/I/K全カードからランダム35枚ずつ抽出）
            let occDeck = shuffle(occupations).slice(0, 35);
            let minDeck = shuffle(minors).slice(0, 35);
            for (let i = 0; i < 5; i++) {
                players[i].occHand = occDeck.splice(0, 7);
                players[i].minHand = minDeck.splice(0, 7);
                players[i].pickedOcc = [];
                players[i].pickedMin = [];
            }
            round = 0;
            selectedOccIndex = -1;
            selectedMinIndex = -1;
            document.getElementById('roundActions').style.display = 'none'; // 非表示リセット
            // document.getElementById('ratingSelection').style.display = 'none'; // ボタン消さない
            showHand();
        }
        // function updateTurnInfo() {
        //     document.getElementById('turnInfo').innerHTML = `<p style="font-weight: bold; color: blue;">あなたの番手: ${playerTurn}番手</p>`;
        // }
        function showHand() {
            // updateTurnInfo(); // 番手表示なし
            // 手札をrating降順ソート（表示時のみ、ピックには影響なし）
            const sortedOccHand = [...players[0].occHand].sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0)); // 選択されたrating使用
            const sortedMinHand = [...players[0].minHand].sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
            const handDiv = document.getElementById('playerHand');
            handDiv.innerHTML = '<h2>' + playerTurn + '番手の手札</h2>'; // 番手に置き換え
            handDiv.innerHTML += '<div class="hand"><h3>職業</h3>' + sortedOccHand.map((c) => {
                const originalIndex = players[0].occHand.findIndex(card => card.name_jp === c.name_jp); // name_jpでマッチ（ユニーク前提）
                const isSelected = originalIndex === selectedOccIndex;
                const combos = checkCombos(c, players[0].pickedOcc.concat(players[0].pickedMin).concat(players[0].occHand).concat(players[0].minHand)); // 候補同士+手札を含む
                const hasCombo = combos.length > 0;
                const comboMark = hasCombo ? `<span class="combo-mark">コンボ</span>` : '';
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card ${isSelected ? 'selected' : ''}" onclick="pickCard('occ', ${originalIndex}); showComboReason('${c.name_jp}', '${combos.join('\\n')}')">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}${comboMark}</div>`;
            }).join('') + '</div>';
            handDiv.innerHTML += '<div class="hand"><h3>進歩</h3>' + sortedMinHand.map((c) => {
                const originalIndex = players[0].minHand.findIndex(card => card.name_jp === c.name_jp);
                const isSelected = originalIndex === selectedMinIndex;
                const combos = checkCombos(c, players[0].pickedOcc.concat(players[0].pickedMin).concat(players[0].occHand).concat(players[0].minHand)); // 候補同士+手札を含む
                const hasCombo = combos.length > 0;
                const comboMark = hasCombo ? `<span class="combo-mark">コンボ</span>` : '';
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card ${isSelected ? 'selected' : ''}" onclick="pickCard('min', ${originalIndex}); showComboReason('${c.name_jp}', '${combos.join('\\n')}')">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}${comboMark}</div>`;
            }).join('') + '</div>';
            
            const pickedDiv = document.getElementById('pickedCards');
            pickedDiv.innerHTML = '<h2>' + playerTurn + '番手の選んだカード</h2>'; // 番手に置き換え
            pickedDiv.innerHTML += '<div class="picked-list"><h3>職業</h3>' + players[0].pickedOcc.map(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            }).join('') + '</div>';
            pickedDiv.innerHTML += '<div class="picked-list"><h3>進歩</h3>' + players[0].pickedMin.map(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                return `<div class="card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            }).join('') + '</div>';
            document.getElementById('status').innerHTML = `<button id="okButton" onclick="passHand()" ${selectedOccIndex === -1 || selectedMinIndex === -1 ? 'disabled' : ''}>OK</button>`;
        }
        function pickCard(type, index) {
            if (type === 'occ') {
                selectedOccIndex = index;
            } else {
                selectedMinIndex = index;
            }
            showHand();
        }
        function passHand() {
            if (selectedOccIndex === -1 || selectedMinIndex === -1) return;
            // プレイヤー1のピック
            const pickedOcc = players[0].occHand.splice(selectedOccIndex, 1)[0];
            const pickedMin = players[0].minHand.splice(selectedMinIndex, 1)[0];
            players[0].pickedOcc.push(pickedOcc);
            players[0].pickedMin.push(pickedMin);
            // 候補更新 (ピック後、残り手札から下位カード)
            if (round === 0) { // 1枚目ピック後 (round=0)
                // 残り手札からrating低い順にソート
                const remainingOcc = players[0].occHand.sort((a, b) => (a[selectedRating] || 0) - (b[selectedRating] || 0));
                const remainingMin = players[0].minHand.sort((a, b) => (a[selectedRating] || 0) - (b[selectedRating] || 0));
                sixthCandidatesOcc = remainingOcc.slice(0, 3); // 下位3枚 (6枚目候補)
                sixthCandidatesMin = remainingMin.slice(0, 3); // 下位3枚 (6枚目候補)
            } else if (round === 1) { // 2枚目ピック後 (round=1)
                const remainingOcc = players[0].occHand.sort((a, b) => (a[selectedRating] || 0) - (b[selectedRating] || 0));
                const remainingMin = players[0].minHand.sort((a, b) => (a[selectedRating] || 0) - (b[selectedRating] || 0));
                seventhCandidatesOcc = remainingOcc.slice(0, 2); // 下位2枚 (7枚目候補)
                seventhCandidatesMin = remainingMin.slice(0, 2); // 下位2枚 (7枚目候補)
            }
            // 候補ゾーン表示更新
            updateCandidateZone();
            // 他のプレイヤー（AI）は常に最高ratingのカードをピック
            for (let i = 1; i < 5; i++) {
                players[i].occHand.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
                const bestOcc = players[i].occHand.shift();
                players[i].pickedOcc.push(bestOcc);
                players[i].minHand.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
                const bestMin = players[i].minHand.shift();
                players[i].pickedMin.push(bestMin);
            }
            // 手札回転: 職業時計回り、進歩反時計回り
            const nextOcc = players.map(p => p.occHand);
            const nextMin = players.map(p => p.minHand);
            for (let i = 0; i < 5; i++) {
                players[i].occHand = nextOcc[(i + 1) % 5];
                players[i].minHand = nextMin[(i + 4) % 5];
            }
            round++;
            selectedOccIndex = -1;
            selectedMinIndex = -1;
            if (round < 7) {
                showHand();
            } else {
                document.getElementById('status').innerHTML = 'ドラフト終了！';
                document.getElementById('candidateZone').style.display = 'none'; // ドラフト終了後に候補ゾーン非表示
                showHand(); // 最終手札はピック済みなので表示更新
                showRoundActions(); // ドラフト後ラウンド選択UI表示
            }
        }
        function updateCandidateZone() {
            const candidateDiv = document.getElementById('candidateZone');
            candidateDiv.style.display = 'block';
            candidateDiv.innerHTML = '<h2>ピック候補</h2>';
            candidateDiv.innerHTML += '<div class="candidate-container">';
            candidateDiv.innerHTML += '<div class="candidate-column">';
            candidateDiv.innerHTML += '<h3 class="candidate-title">6枚目候補</h3>';
            candidateDiv.innerHTML += '<div class="candidate-hand">';
            // 昇順 (低い順) から降順 (高い順) にソートして表示
            sixthCandidatesOcc.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
            sixthCandidatesMin.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
            sixthCandidatesOcc.forEach(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                candidateDiv.innerHTML += `<div class="card candidate-card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            });
            sixthCandidatesMin.forEach(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                candidateDiv.innerHTML += `<div class="card candidate-card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            });
            candidateDiv.innerHTML += '</div>';
            candidateDiv.innerHTML += '</div>';
            candidateDiv.innerHTML += '<div class="candidate-column">';
            candidateDiv.innerHTML += '<h3 class="candidate-title">7枚目候補</h3>';
            candidateDiv.innerHTML += '<div class="candidate-hand">';
            // 昇順 (低い順) から降順 (高い順) にソートして表示
            seventhCandidatesOcc.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
            seventhCandidatesMin.sort((a, b) => (b[selectedRating] || 0) - (a[selectedRating] || 0));
            seventhCandidatesOcc.forEach(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                candidateDiv.innerHTML += `<div class="card candidate-card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            });
            seventhCandidatesMin.forEach(c => {
                const imgTag = c.image_url ? `<img src="${c.image_url}" alt="${c.name_jp || '不明'}" onerror="this.src='agricola_images/placeholder.jpg'">` : '';
                candidateDiv.innerHTML += `<div class="card candidate-card">${imgTag} <br>${c.name_jp || '不明'} ${c[selectedRating] || '?'}</div>`;
            });
            candidateDiv.innerHTML += '</div>';
            candidateDiv.innerHTML += '</div>';
            candidateDiv.innerHTML += '</div>';
        }
        function showRoundActions() {
            const roundActionsDiv = document.getElementById('roundActions');
            roundActionsDiv.style.display = 'block';
            roundActionsDiv.innerHTML = '<h2>ラウンドアクション選択</h2>';
            for (let r = 1; r <= 4; r++) {
                roundActionsDiv.innerHTML += `<div class="round-section"><h3 class="round-header">R${r}</h3>` +
                    createInput('1手目:') +
                    createInput('2手目:') +
                    '<br>' + // 飯以降開行
                    '<div class="action-group">' +
                    createSelect('飯', [0,1,2,3,4,5,6,7,8]) +
                    createSelect('木', [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) +
                    createSelect('レ', [0,1,2,3,4,5,6]) +
                    createSelect('葦', [0,1,2,3,4,5]) +
                    createSelect('石', [0,1,2,3]) +
                    createSelect('麦', [0,1,2,3,4]) +
                    createSelect('野', [0,1,2,3,4]) +
                    '</div>' +
                    '</div>';
            }
        }
        function createInput(label) {
            return `<label class="round-label">${label} <input type="text" class="round-input" pattern="^[ぁ-ゖ]+$" title="全角ひらがなのみ入力してください"></label>`;
        }
        function createSelect(label, options) {
            let select = '<select class="round-select">';
            options.forEach(opt => {
                select += `<option value="${opt}">${opt}</option>`;
            });
            select += '</select>';
            return `<label class="round-label">${label} ${select}</label>`;
        }
        // コンボチェック関数（JSONに"combos"キーがある前提: c.combos = [{target_id: "ID", reason: "説明"} ]）
        function checkCombos(card, allCards) {
            if (!card.combos) return [];
            return card.combos.filter(combo => allCards.some(p => p.id === combo.target_id)).map(combo => combo.reason);
        }
        // コンボ理由表示関数
        function showComboReason(cardName, reasons) {
            document.getElementById('comboInfo').innerHTML = `<h3>${cardName}のコンボ理由</h3><p>${reasons.replace(/\\n/g, '<br>')}</p>`;
        }
    </script>
</body>
</html>